<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.4" />
<title>How To Write A ForgePlucker Handler Class</title>
<style type="text/css">
/* Sans-serif font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
div#toctitle,
span#author, span#revnumber, span#revdate, span#revremark,
div#footer {
  font-family: Arial,Helvetica,sans-serif;
}

/* Serif font. */
div.sectionbody {
  font-family: Georgia,"Times New Roman",Times,serif;
}

/* Monospace font. */
tt {
  font-size: inherit;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  font-size: inherit;
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
}

div#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  div#footer-badges { display: none; }
}

div#toc {
  margin-bottom: 2.5em;
}

div#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }
</style>
<script type="text/javascript">
/*<![CDATA[*/
window.onload = function(){asciidoc.footnotes();}
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  var cont = document.getElementById("content");
  var noteholder = document.getElementById("footnotes");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      // Use [\s\S] in place of . so multi-line matches work.
      // Because JavaScript has no s (dotall) regex flag.
      note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      spans[i].innerHTML =
        "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
        "' title='View footnote' class='footnote'>" + n + "</a>]";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
}

}
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>How To Write A ForgePlucker Handler Class</h1>
<span id="author">Eric S. Raymond</span><br />
<span id="email"><tt>&lt;<a href="mailto:esr@thyrsus.com">esr@thyrsus.com</a>&gt;</tt></span><br />
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Forgeplucker is a web-scraper.  It pulls project data out of forge
sites through the same HTML intercaces human beings use.  Therefore,
for each distinct forge type, it needs a handler class to tell it
how to extract data from that forge. This document explains how to
write a handler class.</p></div>
<div class="paragraph"><p>Before coding, it would probably be a good idea for you to
at least skim the <a href="external.html">blog entries that gave birth to
this project</a>.  It may help you understand the design philosophy
of the code better.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pragmatics_of_web_scraping">Pragmatics of Web-Scraping</h2>
<div class="sectionbody">
<div class="paragraph"><p>Your handler class&#8217;s job is to extract project data.  If you are
lucky, your target forge already has an export feature that will dump
everything to you in clean XML or JSON; in that case, you have a
fairly trivial exercise using BeautifulStoneSoup or the Python-library
JSON parser and can skip the rest of this section.</p></div>
<div class="paragraph"><p>Usually, however, you&#8217;re going to need to extract the data from
the same pages that humans use.  This is a problem, because these
pages are cluttered with all kinds of presentation-level markup,
headers, footers, sidebars, and site-navigation gorp&#8201;&#8212;&#8201;any
of which is highly likely to mutate any time the UI gets tweaked.</p></div>
<div class="paragraph"><p>Here are the tactics we use to try to stay out of trouble:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
When you don&#8217;t see what you expect, use the framework&#8217;s
self.error() call to abort with a message.  And put in <strong>lots</strong> of
expect checks; it&#8217;s better for a handler to break loudly and soon than
to return bad data.  Fixing the handler to track a page mutation
won&#8217;t usually be hard once you know you need to - and knowing you
need to is why we have regression tests.
</p>
</li>
<li>
<p>
Use peephole analysis with regexps (as opposed to HTML parsing
of the whole page) as much as possible.  Every time you get away with
matching on strictly local patterns, like special URLs, you avoid
a dependency on larger areas of page structure which can mutate.
</p>
</li>
<li>
<p>
Throw away as many irrelevant parts of the page as you can before
attempting either regexp matching or HTML parsing. (The most
mutation-prone parts of pages are headers, footers, and sidebars;
that&#8217;s where the decorative elements and navigation stuff tend to
cluster.) If you can identify fixed end strings for headers or fixed
start strings for footers, use those to trim (and error out if they&#8217;re
not there); that way you&#8217;ll be safe even if the headers and footers
mutate.  This is what the narrow() method in the framework code is
for.
</p>
</li>
<li>
<p>
Rely on forms. You can assume you&#8217;ll be logged in with
authentication and permissions to modify project data, which means the
forge will display forms for editing things like issue data and
project-member permissions. Use the forms structure, as it is much
less likely to be casually mutated than the page decorations.
</p>
</li>
<li>
<p>
When you must parse HTML,
<a href="http://www.crummy.com/software/BeautifulSoup/documentation.html">BeautifulSoup</a>
is available to handler classes.  Use it, rather than hand-rolling a
parser, unless you have to cope with markup so badly malformed that it
cannot cope.
</p>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="_handler_class_output">Handler Class Output</h2>
<div class="sectionbody">
<div class="paragraph"><p>The handler class will have mathods for retrieving various portions of
the project state.  Some of these you will not need to define; they&#8217;re
methods of the GenericForge class that will work when you provide the
correct implementation methods in your derived class.  Others you will
need to write yourself.</p></div>
<div class="sect2">
<h3 id="_output_methods">Output Methods</h3>
<div class="paragraph"><p>Here are the methods every handler class must implement:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
pluck_trackers(timeless=False)
</dt>
<dd>
<p>
   Fetch the contents of all trackers. If timeless is true, omit
   pull-interval timestamps (used for regression tests).  If you use
   GenericForge, you don&#8217;t need to define this.
</p>
</dd>
<dt class="hdlist1">
pluck_artifact(tracker, issueid, vocabularies=None)
</dt>
<dd>
<p>
   Fetch a particular tracker item.  The <em>tracker</em> argument must
   be a tracker name this project defines (usually "bugs", "features",
   "tasks", or "support"). The <em>issueid</em> argument  is a string or
   numeric bug ID. If <em>vocabularies</em> is not None, it will be treated
   as a dictionary and filled with tracker attribute vocabularies (see
   more about this in the discussion of ontology smoothing).
</p>
</dd>
<dt class="hdlist1">
pluck_permissions()
</dt>
<dd>
<p>
   Get the project&#8217;s member-permissions table. The ways to fetch these
   are quite idiosyncratic by forge type, so framework code can&#8217;t
   help here: you&#8217;ll have to write your own method from scratch.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Each of these methods should return a JSON-conformable python
dictionary object. What should be <strong>in</strong> that object is the tricky part.
Different forges support different data models, so not all output
format will be identicals.  Here are some guidelines:</p></div>
</div>
<div class="sect2">
<h3 id="_output_guidelines">Output Guidelines</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<strong>Try for 100% faithful data capture.</strong> Never throw away state,
   because you can never tell when a handler user might need it.
</p>
</li>
<li>
<p>
<strong>Make the dump look as much like an existing format as possible.</strong>
   Re-use class tags, structures and fieldnames from the sample dumps
   you&#8217;ll find in the regression check files.  The Gna! regression
   check makes an especially good guide, as the data model of that
   forge is richer than most others.
</p>
</li>
<li>
<p>
<strong>Make it self-describing.</strong>  Use "class" tags on objects to
   label the individual subparts with what they&#8217;re for.  This will
   help client software, which should be able to use these to
   (among other things) not have to retain a lot of state about
   where it is when it&#8217;s crawling over the tree.
</p>
</li>
</ol></div>
<div class="paragraph"><p>In order to support cross-forge statistical analyses, re-import, and
other good things, these dumps will eventually have to be massaged
into using a common data model.  The project&#8217;s term for this is "ontology
smoothing", and you need to be careful not to try to do too much
of it in the handler class.</p></div>
<div class="paragraph"><p>In general, the handler class should only transform the data in ways
that are trivial, lossless, and make it look more like one of the
pre-existing formats.  Complicated and potentially lossy
transformations should be left up to the code calling these handlers.</p></div>
<div class="paragraph"><p>Here&#8217;s an example.  On both Berlios and Savane, the member capability
that allows tracker items to be assigned to a member is "Technician",
abbreviated "T". But the capability required to <strong>edit</strong>
tracker issue items is called different things: "Administrator" on
Berlios and "Manager" on Savane.  We prefer to use Savane
terminology, reserving "Administrator" for someone with the capability
to edit member permissions; so we smooth those capability names
to "T" and "M" on both forges.</p></div>
<div class="paragraph"><p>When you code ontology smoothing, explain it carefully in a comment
with the words "ontology smoothing" actually in it.  And keep it
carefully separated from the actual extraction logic, in case
someone needs to change it someday.</p></div>
<div class="paragraph"><p>We have some more specific rules that mostly derive from these general
guidelines, but I&#8217;ve shuffled those off to an appendix so they won&#8217;t
clutter the exposition here.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_defining_the_handler">Defining the Handler</h2>
<div class="sectionbody">
<div class="paragraph"><p>Handler classes live in a multi-file module called <em>forgeplucker</em>;
look in the directory by that name in the source distribution.  A new
handler named <em>Foo</em> should live in a file named
forgeplucker/handle_foo.py.  Other modules in that directory are
support code: htmlscrape.py contains low-level functions for scraping
HTML, and generic.py is the framework code for a generic forge.</p></div>
<div class="paragraph"><p>Begin by declaring a new class for your forge type and adding it to
the <em>handlers</em> variable in forgeplucker/<em>init</em>.py; you will also
need a corresponding import statement.  If it is associated with a well-known
domain address, add that association to the <em>site_to_handler</em> dictionary.</p></div>
<div class="paragraph"><p>Your handler should inherit from the GenericForge class, which will
supply its logic skeleton and various default methods that often work for
forge systems descended from SourceForge.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>class FooForge(GenericForge):
    "Handler class for forge sites running the FooForge hosting suite."
    pass</tt></pre>
</div></div>
<div class="paragraph"><p>The <em>pass</em> is a placeholder statement; as written, our class does not yet have
real methods or members and is an exact clone of GenericForge.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_logging_in">Logging In</h2>
<div class="sectionbody">
<div class="paragraph"><p>One of these methods FooForge will inherit is <em>login_url()</em>.  The
GenericForge version assumes that the site login form is at
"http://%s/account/login.php", where %s gets the sitename substituted;
this often works without modification. If the login page as at a
different location on your forge system, you will have to write a
login_url() method for you handler to override the one from
GenericForge, but this is unusual.</p></div>
<div class="paragraph"><p>The first method you are likely to actually have to write will be be the
site login method, usually something like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>class FooForge(GenericForge):
    "Handler class for forge sites running the FooForge hosting suite."
    def login(self, username, password):
        response = GenericForge.login(self, {
            'form_loginname':username,
            'form_pw':password,
            'stay_in_ssl':1,
            'login':'Login With SSL'},
            "Personal Page")</tt></pre>
</div></div>
<div class="paragraph"><p>You&#8217;ll need to look at the login page source to see what form elements
it actually requires. You&#8217;ll also need to change "Personal Page" to a
string that reliably occurs on the page you get on successful login,
and does <strong>not</strong> occur on the page returned by an unsuccessful login.
This is how your handler robot will tell whether it has entered the
site properly and can proceed to fetch data.  GenericForge will take
care of handling authentication cookies for your session once your
handler has logged in.</p></div>
<div class="paragraph"><p>I find the Firefox LiveHeaders extension useful for debugging these
methods.  It&#8217;s easy to miss a required form element in the visual
clutter of a login page&#8217;s source, but with LiveHeaders, you can snoop
the transaction to see what a successful login through Firefox
is actually sending.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_the_project_id">Getting the Project ID</h2>
<div class="sectionbody">
<div class="paragraph"><p>Projects on a forge system has a "Unix name" which is a legal Unix
directory segment, conventionally an abbreviated name of the project
in all-lowercase letters.  This name is used to generate path names
for files and CGI scripts associated with the project.  On most
modern forge systems, this Unix name identifies the project
for all purposes.</p></div>
<div class="paragraph"><p>On forge systems descended from older SourceForge versions, each
project has a second internal project ID that is all numeric and
not related to the Unix name in any obvious way.  If that ID exists,
it has to be used rather than the Unix name in generating various
kinds of URL into the site.</p></div>
<div class="paragraph"><p>If you find one of these older systems we don&#8217;t already support,
you&#8217;ll have to write logic to get the numeric project ID from the Unix
name, one, just after you log in.  For an example of how this is done,
see the method numid_from_name() in the Berlios handler.</p></div>
<div class="paragraph"><p>In other methods you will need to use project Unix name or project
numeric ID as appropriate. In the rest of this document, we&#8217;ll assume
that your forge stem identifies projects in the modern style requiring
Unix name only; adjust as needed.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_extracting_tracker_state">Extracting Tracker State</h2>
<div class="sectionbody">
<div class="paragraph"><p>The first thing you&#8217;ll want to do is write logic to extract the
project&#8217;s issue-tracker state.</p></div>
<div class="paragraph"><p>In order to write the code to do this, you need to know what
GenericForge does to fetch tracker state.  For each tracker, it first
tries to fetch an index page listing artifact IDs. If there are more IDs
than fit on the first index page, (usually this means <em>more than 50</em>)
it fetches the next index page and repeats.</p></div>
<div class="paragraph"><p>Once it has the entire list of artifact IDs, it then fetches the detail
page for each ID on the page and parses out the artifact information on
that.</p></div>
<div class="paragraph"><p>The code for doing all these things lives in tracker classlets, little
auxiliary classes visible only from within your forge handler.  There
will be one classlet for each tracker type the forge supports; a
typical type set might include "bugs", "features", "support",
"patches", and "tasks".  You will probably also want to write a base
Tracker classlet for the others to inherit from; on well-designed
forges most of the logic will live there, with only trivial variations
in the derived ones.</p></div>
<div class="paragraph"><p>The most effective way to understand how tracker classlets work is
to look at a working one.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    class Tracker:
        "Generic tracker classlet for Savane."
        def __init__(self, parent):
            self.parent = parent
            self.optional = True
            self.chunksize = 50
            self.zerostring = "No matching items found"
            self.artifactid_re = r'&lt;a href="\?([0-9]+)"&gt;'
            # This may yield anchor markup around the submitter name.
            # Sometimes it's present, if the submitter is a known user
            self.submitter_re = r'Submitted by:&amp;nbsp;&lt;/td&gt;\s*&lt;td[^&gt;]*&gt;(&lt;a[^&gt;]*&gt;[^&lt;]*&lt;/a&gt;|[^&lt;]+)&lt;/td&gt;'
            self.date_re = r'Submitted on:[^&lt;]*&lt;/td&gt;\s*&lt;td[^&gt;]*&gt;([^&lt;]*)&lt;/td&gt;'
            self.ignore = ('canned_response',
                           'comment_type_id',
                           'depends_search_only_artifact',
                           'depends_search_only_project',
                           'reassign_change_artifact',
                           "add_cc",
                           "cc_comment",
                           "new_vote")</tt></pre>
</div></div>
<div class="paragraph"><p>The tracker classlet needs a reference to the owning forge handler
class. That&#8217;s what self.parent is.</p></div>
<div class="paragraph"><p>On some forge systems, all projects always have all tracker types. On
others, the set of trackers is configurable by project administrators.
If the <em>optional</em> member is False, treat failure to fetch an index
page for this tracker as a fatal error. If it&#8217;s true, simply skip this
tracker when it&#8217;s missing.</p></div>
<div class="paragraph"><p>The chunksize member is the expected number of bugs per index page.
It&#8217;s used in computing URLs for index page fetches.</p></div>
<div class="paragraph"><p>Some forges have a recognizable string that means a tracker index is
empty.  This is good to know, because if we have such a <em>zerostring</em>
entry, and it&#8217;s not on the page, and we still count no artifacts, we
can throw an error.  If this ever happens it will mean the site has
changed its HTML generation enough that the bug-plucker won&#8217;t work
any more. If that happens, we want to fail noisily rather than
returning a bogus empty dump.</p></div>
<div class="paragraph"><p>The <em>artifactid_re</em> member is the regular expression we use to mine bug
ID numbers out of an index page.</p></div>
<div class="paragraph"><p>The <em>submitter_re</em> and <em>date_re</em> members are the regular expression we
used to mine the artifact submitter and date out of an artifact detail page
fetched by ID.</p></div>
<div class="paragraph"><p>To get the rest of the data about an artifact from its detail page,
GenericForge does various kinds of parsing of the HTML.  One thing
it looks for is the contents of form fields.  The <em>ignore</em> member
is a list of the names of form fields to ignore.  In this example,
all the names up to <em>reassign_change_artifact</em> belong to fields on
auxiliary forms that control the forge interface rather than
reflecting project data.  The later ones are for user entry fields
for new data; they&#8217;ll be empty in this case.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>        def access_denied(self, page, issue_id=None):
            return issue_id is not None and re.search("This task has [0-9]+ encouragements? so far.", page)</tt></pre>
</div></div>
<div class="paragraph"><p>The method for telling whether we failed to get tracker technician
access to the project. Without this, we don&#8217;t get the right form
elements on detail pages to be able to parse out the data. This metod
is called on index pages with issue_id=None and on detail pages with
the error ID as argument; if it is ever True, the generic forge
framework code will throw an access-denied error.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>        def has_next_page(self, page):
            m = re.search("([0-9]+) matching items - Items [0-9]+ to ([0-9]+)", page)
            if not m:
                self.parent.error("missing item count header")
            else:
                return int(m.group(1)) &gt; int(m.group(2))</tt></pre>
</div></div>
<div class="paragraph"><p>The method for checking whether or not there&#8217;s a next page.  Observe
that it throws an error if it doesn&#8217;t see what it&#8217;s expecting.  In order
not to get spurious data, it&#8217;s best when our web-scraping methods
have lots and lots of sanity checks, and fail loudly when one
doesn&#8217;t pass.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>        def chunkfetcher(self, offset):
            "Get a tracker index page - all artifact IDs, open and closed.."
            return "%s/index.php?go_report=Apply&amp;group=%s&amp;func=browse&amp;set=custom&amp;chunksz=50&amp;offset=%d" % (self.type, self.parent.project_name, offset)
        def detailfetcher(self, artifactid):
            "Generate a detail URL for the specified artifact ID."
            return "%s/index.php?%d" % (self.type, artifactid)</tt></pre>
</div></div>
<div class="paragraph"><p>Generate the URLs to get index pages and artifact detail pages.
Note that the URLs generated are local; the GenericForge methods will
add the sitename and service prefix.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>        def narrow(self, text):
            "Get the section of text containing editable elements."
            return self.parent.skipspan(text, "form", 1)</tt></pre>
</div></div>
<div class="paragraph"><p>Now we get to the more difficult parts. First, the <em>narrow()</em> method
gets the part of the webpage that is interesting for data-extraction
purposes.  This will be an HTML &lt;FORM&gt; element, often but not
necessarily the second one in sequence. (On many systems there will be
an earlier form containing a site search box, which is rendered as
part of a sidebar.)</p></div>
<div class="paragraph"><p>Once the right form has been extracted, there&#8217;s a lot of data that the
GenericForge code can extract automatically just by looking at
&lt;SELECT&gt; elements and text &lt;INPUT&gt; boxes.</p></div>
<div class="paragraph"><p>The artifact&#8217;s Open/Closed status will do for an example.  Because we
logged in with tracker-technician credentials, the Open/Closed status
is presented as a drop-down menu generated by a select.  By looking
for the &lt;SELECT&gt;, we avoid having to parse prsentation-level tag soup.
As a side benefit, looking at the contained &lt;OPTION&gt; elements tells us
not only the current value of the field, but all possible values.</p></div>
<div class="paragraph"><p>The most important thing we get from text &lt;INPUT&gt; elements is the
artifact summary line.  If the project has custom metadata fields,  for
tems, this part of the parse will pick them up as well.</p></div>
<div class="paragraph"><p>This is also when the <em>submitter_re</em> and <em>submitter_date</em> regexpa get
applied to extract the submitter&#8217;s name.  These aren&#8217;t in form elements
because they can&#8217;t be modified after the artifact is created.</p></div>
<div class="paragraph"><p>Most of the forge-type-specific work of parsing datra out of a detail
page goes in a method called <em>custom</em> which has to be custom-written
for each forge type.  Here&#8217;s the one for Savane.  It&#8217;s responsible
for parsing artifact comments (that part is handed iff to a helper),
votes, and modification history.  Essentially, everything we can&#8217;t
extract automatically be looking at &lt;FORM&gt; elements.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>        def custom(self, contents, artifact):
            artifact['comments'] = self.parent.parse_followups(contents)
            artifact["attachments"] = []
            for m in re.finditer(r'&lt;a href="([^"]*)"&gt;file #([0-9]+): &amp;nbsp;([^&lt;]*)&lt;/a&gt; added by &lt;a href="[^"]*"&gt;([^&lt;]*)&lt;/a&gt; &lt;span class="smaller"&gt;\((\w+) - ([^)]*)\)', contents):
                filename = m.group(1)
                fileid = m.group(2)
                filename = m.group(3)
                attacher = m.group(4)
                size = m.group(5)
                mimetype = m.group(6)
                artifact["attachments"].append({
                    "class":"ATTACHMENT",
                    "filename": filename,
                    "id": fileid,
                    "attached_by": attacher,
                    "size":size,
                    "mimetype":mimetype,
                    })
            if ("No files currently attached" in contents) != (len(artifact["attachments"])==0):
                self.parent.error("garbled file-attachment section, possible version-skew problem.")
            artifact['votes'] = None
            if "There is 1 vote so far." in contents:
                artifact['votes'] = 0
            else:
                m = re.search("There are ([0-9]*) votes so far.", contents)
                if m:
                    artifact['votes'] = int(m.group(1))
            if artifact['votes'] is None:
                raise('cannot find a vote indication')
            artifact["history"] = []
            for (date, by, field, old, dummy, new) in self.parent.table_iter(contents,
                                                                             "History",
                                                                             6,
                                                                             "history",
                                                                             has_header=True):

                # Savane leaves the Date and Changed-by fields blank
                # (actually, containing &amp;nbsp;) when they represent
                # the second or later field changes made at one time.
                if date[-1].isdigit():
                    date = self.parent.isodate(date)
                elif date == '&amp;nbsp;':
                    date = ''
                if by == '&amp;nbsp;':
                    by = ''
                artifact["history"].append({"class":"EVENT",
                                        'field': field,
                                        'old': old,
                                        'new': new,
                                        'date':date,
                                        'by': by})</tt></pre>
</div></div>
<div class="paragraph"><p>It&#8217;s very common for forge systems to structure sequences in output
(such as sequences of comments, or modification histories) as tables
A lot of the hard work in this implementation of <em>custom</em> gets done by
helper functions that walk through tales with specific titles.</p></div>
<div class="paragraph"><p>Now let&#8217;s look at the actual tracker classes.  Savane has s relatively
well-defined user interface; the trackers all behave the same way,
so users can form consistent behavioral expectations.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    class BugTracker(Tracker):
        def __init__(self, parent):
            Savane.Tracker.__init__(self, parent)
            self.type = "bugs"
    class PatchTracker(Tracker):
        def __init__(self, parent):
            Savane.Tracker.__init__(self, parent)
            self.type = "patch"
    class TaskTracker(Tracker):
        def __init__(self, parent):
            Savane.Tracker.__init__(self, parent)
            self.type = "task"
    class SupportTracker(Tracker):
        def __init__(self, parent):
            Savane.Tracker.__init__(self, parent)
            self.type = "support"</tt></pre>
</div></div>
<div class="paragraph"><p>The <em>type</em> member will be used to name the tracker data in the
output report.</p></div>
<div class="paragraph"><p>Now we&#8217;ll look at the Savane handler class itself:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    def __init__(self, host, project_name):
        GenericForge.__init__(self, host, project_name);
        self.host = host
        self.project_name = project_name
        self.verbosity = 0
        self.trackers = [Savane.BugTracker(self),
                         Savane.SupportTracker(self),
                         Savane.TaskTracker(self),
                         Savane.PatchTracker(self)]</tt></pre>
</div></div>
<div class="paragraph"><p>The key thing here is instantiating the list of tracker objects.  The
GenericForge code will walk through this list looking for data from
each of them.</p></div>
<div class="paragraph"><p>Our next function canonicalizes dates into ISO 8601 form.  Other code
calls this through the GenericForge method isodate(), which will catch
format mismatch errors and convert them to ForgePlucker errors we can
dispatch on. The code should be pretty self-explanatory.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    @staticmethod
    def canonicalize_date(date):
        "Canonicalize Savane dates to ISO."
        # SavaneCleanup dates will look like this: Fri 22 Jun 2001
        # 09:54:07 AM UTC. The timezone is variable according to the
        # user's preferences; sometimes SavaneCleanup omits the
        # timezone. Beware that strptime(3) doesn't actually interpret
        # %Z, it only barfs on bad values. So we have to do it.
        #
        # Savane dates may look like this: "Sun Jul 27 11:08:45 2008"
        # (note the absence of timezone and that time and year are swapped)
        # or like this: "Thursday 10/15/2009 at 06:40".
        if date == '-':                 # Gna! sometimes generates these
            return 'None'
        if '/' in date:                 # Gna! date
            t = time.strptime(date, "%A %m/%d/%y at %H:%M")
        elif date[-1].isalpha():        # Savannah date with timezone
            t = time.strptime(date, "%a %d %b %Y %H:%M:%S %p %Z")
        else:                           # Savannah date without timezone
            t = time.strptime(date, "%a %b %d %H:%M:%S %Y")
        if "UTC" in date or "GMT" in date:
            secs = calendar.timegm(t)   # struct time in UTC to secs since epoch
        else:
            secs = time.mktime(t)       # struct local time to secs since epoch
        t = time.gmtime(secs)           # secs since epoch to struct UTC time
        return time.strftime("%Y-%m-%dT%H:%M:%SZ", t)</tt></pre>
</div></div>
<div class="paragraph"><p>Every forge handler needs a login method. The GenericForge method
takes a dictionary of requirted login-form elements and a check
string.  If the form response fails to contain the chreck string,
the login failed and the GenericForge code will throw an error.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    def login(self, username, password):
        response = GenericForge.login(self, {
            'uri':'/',
            'form_loginname':username,
            'form_pw':password,
            'stay_in_ssl':1,
            'brotherhood':1,
            'login':'Login'}, "My Incoming Items")</tt></pre>
</div></div>
<div class="paragraph"><p>Now the code for parsing comments on detail pages.  Older
SourceForge-based systems distinguish between the original submission
and other comments, presenting them slightly differently.  Savane
doesn&#8217;t&#8201;&#8212;&#8201;the submission comment is just comment #0 in the sequence.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    def parse_followups(self, contents):
        "Parse followups out of a displayed page in a bug or patch tracker."
        comments = []
        # Look for the anchor Savane creates for the Discussion section.
        begin = contents.find('href="#discussion"')
        if begin == -1:
            self.notify("no discussion")
        else:
            contents = contents[begin:].replace("&lt;br /&gt;", "&lt;br/&gt;")
            # There's no decorative header element in this table.
            for row in walk_table(contents):
                try:
                    # Savane comments have *two* column elents per comment,
                    # one for date and text, the second for the user.
                    (comment, submitter) = row
                    date = comment.split("&lt;br/&gt;")[0]
                    comment = "\n".join(comment.split("&lt;br/&gt;")[1:])
                    # Submitter's name may have HTML markup in it.
                    # But first toss everything after &lt;br/&gt;, it's image
                    # cruft.
                    submitter = submitter.split("&lt;br/&gt;")[0]
                    submitter = dehtmlize(submitter)
                    # Throw out everything past the terminating comma
                    # If this leads to an ill-formed date, because somebody
                    # moved the punctuation, isodate() should throw an error
                    m = re.search("&lt;[^&gt;]+&gt;([^&lt;]+),", date)
                    date = self.isodate(m.group(1))
                    # Comment may have HTML in it. Do normal markup
                    # stripping,but first deal with the funky way that
                    # Savane emits paragraph delimiters.
                    comment = comment.replace("\n\n", "\n")
                    comment = comment.replace("\n&lt;/p&gt;\n&lt;p&gt;", "\n")
                    comment = blocktext(dehtmlize(comment))
                    # Stash the result.
                    comments.append({"class":"COMMENT",
                                     'submitter':submitter,
                                     'date':date,
                                     'comment':comment})
                except ValueError:
                    raise ForgePluckerException("mangled followup,")
        return comments</tt></pre>
</div></div>
<div class="paragraph"><p>The code for fetching the member permissions table.  Not really complicated,
there&#8217;s just a lot of it. Much of it is sanity checks intended to
detect if permissions pages ever change format.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>    def pluck_permissions(self):
        "Retrieve the developer roles table."
        expected_features = [u'Support Tracker',
                             u'Bug Tracker',
                             u'Task Tracker',
                             u'Patch Tracker',
                             u'Cookbook Manager',
                             u'News Manager']
        # This maps some features to standard names.
        feature_map = ('support', 'bugs', 'tasks', 'patch', 'Cookbook', 'News')
        permission_map = {u'Group Default': None,
                          u'None': [],
                          u'Technician': ['T'],
                          u'Manager':['M'],
                          u'Techn. &amp; Manager':['T', 'M']}
        page = self.fetch("project/admin/userperms.php?group=%s" % self.project_name, "Permissions Table")
        if not "Update Permissions" in page:
            self.error("you need admin privileges to extract permissions",
                       ood=False)
        # Ignore all the site navigation crap, it's likely to mutate
        goodstuff = page.find('&lt;form action="/project/admin/userperms.php" method="post"&gt;')
        if goodstuff == -1:
            self.error("permissions form not found where expected")
        else:
            page = page[goodstuff:]
        trailing = page.find("&lt;/form&gt;")
        if trailing == -1:
            self.error("expected trailing &lt;/form&gt; element not found")
        else:
            page = page[:trailing+7]
        # Actual parsing begins here
        form = BeautifulSoup(page)
        # Extract feature headings
        defaults = form("table")[1]
        features = map(lambda x: x.contents[0], defaults.tr.findAll("th"))
        if features != expected_features:
            self.error("feature set %s is not as expected" % features)
        # Extract group default permissions
        defvals = map(lambda x: x.contents[3].strip(), defaults.findAll("td"))
        for d in defvals:
            if not d.startswith("(") or not d.endswith(")"):
                self.error("default group values were not as expected")
        defvals = map(lambda x: x[1:-1].strip(), defvals)
        dfltmap = dict(zip(features, defvals))
        # Extract actual permissions. The [1:] discards the header row
        capabilities = {}
        permissions = form("table")[2].findAll("tr")[1:]
        for row in permissions:
            fields = map(lambda x: x.contents, row.findAll("td"))
            namefield = fields[0]
            baseperms = fields[1]
            try:
                trackerperms = map(lambda x: select_parse(x[1])[0], fields[2:])
            except:
                self.error("tracker permissions were not as expected")
            try:
                name = namefield[1].contents[0]
            except:
                self.error("name field in permissions was not as expected")
            person = dehtmlize(name)
            capabilities[person] = {}
            admin = trusted = False
            if "You are Admin" in baseperms[0]:
                admin = True
            else:
                admin_input = baseperms[1]
                if not 'admin' in `admin_input`:
                    self.error("admin checkbox not found where expected")
                else:
                    admin = 'checked' in `admin_input`
            if admin:
                trusted = True
            for field in baseperms:
                if 'input' in `field` and 'privacy' in `field` and "checked" in `field`:
                    trusted = True
            capabilities[person]["Admin"] = admin
            capabilities[person]["Trusted"] = trusted
            for (feature, value, default) in zip(feature_map, trackerperms, defvals):
                if permission_map[value] is None:
                    value = permission_map[default]
                capabilities[person][feature] = value
        return capabilities</tt></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_your_handler_class">Testing Your Handler Class</h2>
<div class="sectionbody">
<div class="paragraph"><p>To verify your handler class, you should either use an existing
project on the target forge of which you are already a member, or
create a new test project.  Some random project won&#8217;t do, as you will
need tracker administrator access to extract bug state.  It&#8217;s best if you
can create a dedicated forgeplucker-test project in which you can
manipulate and inspect the data as you like.</p></div>
<div class="paragraph"><p>We presently have forgeplucker-test projects at the following places:</p></div>
<div class="ulist"><ul>
<li>
<p>
<a href="https://launchpad.net/forgepluckertest">Launchpad</a>
</p>
</li>
<li>
<p>
<a href="https://developer.berlios.de/projects/forgepluckertst/">Berlios</a>
</p>
</li>
<li>
<p>
<a href="https://savannah.nongnu.org/projects/testymattl/">Savane</a>
</p>
</li>
<li>
<p>
<a href="https://sourceforge.net/projects/forgepluckertes/">SourceForge</a>
</p>
</li>
<li>
<p>
<a href="https://gna.org/projects/forgepluckertest/">Gna!</a>
</p>
</li>
<li>
<p>
<a href="http://code.google.com/p/forgepluckertest/">Google Code</a>
</p>
</li>
</ul></div>
<div class="paragraph"><p>We&#8217;ll join you to all of these with the required access for testing.
Don&#8217;t forget to add your site credentials to .netrc where our code will
see them; see the <a href="forgeplucker.html">forgeplucker manual page</a> for
details.</p></div>
<div class="paragraph"><p>There is a <em>test</em> subdirectory containing regression check files, and
a regression-test harness in the main directory that knows how to
compare state pulls from our dummy projects with those check files.  You
can use the script to test all handlers, rebuild an individial test after
changing a dummy project&#8217;s content, or to rebuild all tests.</p></div>
<div class="paragraph"><p>Run "regress-driver.py --help" to learn its control options.</p></div>
<div class="sect2">
<h3 id="_appendix_rules_for_json_output">Appendix: Rules for JSON Output</h3>
<div class="ulist"><ul>
<li>
<p>
Use ISO-8601 format for dates and timestamps.
</p>
</li>
<li>
<p>
Use the "class" attribute in JSON objects where appropriate to
  indicate the semantic kind you are dumping.  Defined values are:
</p>
<div class="ulist"><ul>
<li>
<p>
ARTIFACT: for a tracker issue
</p>
</li>
<li>
<p>
ATTACHMENT: a file attached to an artifact
</p>
</li>
<li>
<p>
COMMENT: for a comment attached to a tracker issue
</p>
</li>
<li>
<p>
IDENTITY: for the identity of a project member
</p>
</li>
<li>
<p>
PROJECT: for a project state
</p>
</li>
</ul></div>
</li>
<li>
<p>
The top level object (called PROJECT) of your dump should always include the
  following metadata tags:
</p>
<div class="ulist"><ul>
<li>
<p>
forgetype: The name of the handler class it was generated by
</p>
</li>
<li>
<p>
format_version: The current major version of the output format
</p>
</li>
<li>
<p>
host: The FQDN of the site from which it was dumped
</p>
</li>
<li>
<p>
project: The name of the project
</p>
</li>
<li>
<p>
artifacts: list of ARTIFACT objects.
</p>
</li>
<li>
<p>
vocabularies: a dictionary mapping names of controlled-vocabulary
   fields to lists of the values they can have.
</p>
</li>
</ul></div>
</li>
<li>
<p>
Standard fields of an ARTIFACT:
</p>
<div class="ulist"><ul>
<li>
<p>
class: "ARTIFACT"
</p>
</li>
<li>
<p>
assigned_to: None or the nick/IDENTITY of the technician it&#8217;s assigned to
</p>
</li>
<li>
<p>
attachments: list of attached attachments
</p>
</li>
<li>
<p>
comments: list of attached comments
</p>
</li>
<li>
<p>
dependents: list iof bug IDs that depend on this bug
</p>
</li>
<li>
<p>
history: a list of FIELDCHANGE objects
</p>
</li>
<li>
<p>
id: the ID of the artifact
</p>
</li>
<li>
<p>
summary: one-line summary of issue
</p>
</li>
<li>
<p>
type: preferably from controlled vocabulary:
</p>
<div class="ulist"><ul>
<li>
<p>
"bugs"
</p>
</li>
<li>
<p>
"features"
</p>
</li>
<li>
<p>
"patches"
</p>
</li>
<li>
<p>
"support"
</p>
</li>
<li>
<p>
"tasks"
</p>
</li>
</ul></div>
</li>
</ul></div>
</li>
<li>
<p>
Standard fields of a COMMENT:
</p>
<div class="ulist"><ul>
<li>
<p>
class: "COMMENT"
</p>
</li>
<li>
<p>
comment: the comment text
</p>
</li>
<li>
<p>
date: date of comment in ISO format
</p>
</li>
<li>
<p>
submitter: submitter name or IDENTITY
</p>
</li>
</ul></div>
</li>
<li>
<p>
Standard fields of an ATTACHMENT:
</p>
<div class="ulist"><ul>
<li>
<p>
class: "ATTACHMENT"
</p>
</li>
<li>
<p>
by: submitter name or IDENTITY
</p>
</li>
<li>
<p>
date: date of attachment in ISO format
</p>
</li>
<li>
<p>
description: one-line text description of the attachment
</p>
</li>
<li>
<p>
filename: filename of the attached file
</p>
</li>
<li>
<p>
id: ID of the attachment (used for reference in comments)
</p>
</li>
<li>
<p>
mimetype: MIME type of file
</p>
</li>
</ul></div>
</li>
<li>
<p>
Standard fields of a FIELDCHANGE:
</p>
<div class="ulist"><ul>
<li>
<p>
class: "FIELDCHANGE"
</p>
</li>
<li>
<p>
by: nick or IDENTITY of person who made the change
</p>
</li>
<li>
<p>
date: date of changr in ISO format
</p>
</li>
<li>
<p>
field: name of field changed
</p>
</li>
<li>
<p>
new: new value
</p>
</li>
<li>
<p>
old: old value
</p>
</li>
</ul></div>
</li>
<li>
<p>
Standard fields of an IDENTITY:
</p>
<div class="ulist"><ul>
<li>
<p>
class: "PROJECT"
</p>
</li>
<li>
<p>
name: Human name of a person
</p>
</li>
<li>
<p>
nick: A person&#8217;s ID on this forge
</p>
</li>
</ul></div>
</li>
<li>
<p>
Standard capablities of a person:
</p>
<div class="ulist"><ul>
<li>
<p>
"Admin": can edit membership tables
</p>
</li>
<li>
<p>
"Trusted": can look at private items
</p>
</li>
<li>
<p>
"Release Tech": can make releases
</p>
</li>
<li>
<p>
"T": (with respect to a tracker) can be assigned bugs from it
</p>
</li>
<li>
<p>
"M": (with respect to a tracker) can modify bugs on it
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2011-07-07 09:54:05 CEST
</div>
</div>
</body>
</html>
